# Resumo da Aula: Docker Compose para o FlagD e Introdução ao Bônus de Estratégias de Deploy

## Introdução
A aula finaliza a configuração prática do **FlagD** com o **Open Feature**, criando um arquivo **Docker Compose** para simplificar a execução do container, substituindo o comando `docker run` extenso usado anteriormente. O professor enfatiza a importância de monitorar os logs do container para verificar a sincronização automática após alterações no arquivo `flags.json` (ex.: salvar com Ctrl+S). A aula conclui o módulo de Feature Flags e introduz um bônus sobre **estratégias de deploy avançadas** no Kubernetes, conectando o conceito de rollout gradual das Feature Flags a práticas reais de publicação de aplicações.

## Conteúdo Principal

### Dica sobre Sincronização
- **Monitoramento de Logs**: Toda vez que o arquivo `flags.json` é salvo (Ctrl+S), é recomendável verificar os logs do container do FlagD (`docker logs <container_id>`) para confirmar o resync automático das flags. Isso garante que as alterações sejam aplicadas corretamente, evitando inconsistências na aplicação.

### Configuração do Docker Compose
- **Motivação**: O comando `docker run` para o FlagD é extenso e propenso a erros. O **Docker Compose** facilita a execução, especialmente para um único serviço, tornando o ambiente mais reproduzível e fácil de gerenciar.
- **Arquivo `docker-compose.yml`**:
  - Criado no mesmo diretório do projeto `flagd-demo`, sem a versão (campo deprecado):
    ```yaml
    services:
      flagd:
        image: ghcr.io/openfeature/flagd:latest
        container_name: flagd
        ports:
          - "8014:8013"
        volumes:
          - ./flags.json:/etc/flagd/flags.json
        command: ["start", "--uri", "file:/etc/flagd/flags.json"]
    ```
  - **Explicação**:
    - **image**: Usa a imagem oficial do FlagD do GitHub Container Registry (`ghcr.io/openfeature/flagd:latest`).
    - **container_name**: Define o nome como `flagd` para facilitar a referência.
    - **ports**: Mapeia a porta 8014 (host) para 8013 (container, padrão gRPC do FlagD).
    - **volumes**: Monta o arquivo local `./flags.json` no caminho `/etc/flagd/flags.json` dentro do container.
    - **command**: Inicia o FlagD com `start --uri file:/etc/flagd/flags.json`, apontando para o arquivo montado.
- **Execução**:
  - O professor para o container anterior (`docker stop <id>`) e executa `docker compose up`.
  - Um erro inicial ocorre devido a um typo na imagem (`flagd` em vez de `flagd`), corrigido para `ghcr.io/openfeature/flagd:latest`.
  - Com `docker compose up -d` (detached mode), o container roda em background; sem `-d`, fica em foreground para monitorar logs em tempo real.
  - **Verificação**: `docker ps` confirma o container rodando, e `docker logs flagd` mostra o watch e resync ao alterar o `flags.json` (ex.: mudar rollout para 50/50, salvando e verificando o sync).
- **Vantagens**: Simplifica a execução e o monitoramento, permitindo rodar em detached mode (`-d`) para desenvolvimento ou em foreground para observar sincronizações.

### Conclusão do Módulo de Feature Flags
- O conteúdo sobre **FlagD** e **Open Feature** é finalizado, destacando sua abordagem baseada em arquivos JSON para flags, sincronização automática e integração com Open Feature para desacoplamento. A complexidade do JSON é compensada pelo playground (`flagd.dev`) e pela flexibilidade para rollouts e targeting.

### Bônus: Estratégias de Deploy Avançadas no Kubernetes
- **Introdução ao Bônus**: O módulo bônus integra os conceitos de Feature Flags (ex.: rollout gradual) com estratégias de deploy no Kubernetes, indo além das básicas como **Rolling Update** e **Recreate** vistas em módulos anteriores.
- **Foco**: Explorar estratégias avançadas para controlar a publicação de aplicações em um cluster Kubernetes, como **Canary Deployment** e **Blue-Green Deployment**, permitindo lançamentos graduais e seguros para públicos específicos.
- **Relação com Feature Flags**: O rollout gradual das flags se conecta diretamente a essas estratégias, permitindo disponibilizações controladas de features em produção sem impacto total.
- **Próximas Aulas**: Serão mais avançadas, envolvendo ferramentas adicionais do Kubernetes para implementar e testar essas estratégias em um cluster real.

## Conclusão
A aula consolida o uso do **FlagD** com o **Docker Compose**, facilitando a execução e monitoramento do ambiente para testes de Feature Flags. A dica sobre logs reforça a importância da sincronização automática, enquanto o bônus sobre estratégias de deploy no Kubernetes expande o conhecimento para cenários reais de produção. O módulo de Feature Flags é encerrado com ênfase no desacoplamento via Open Feature, preparando o aluno para explorar Canary e Blue-Green Deployments, que complementam o controle gradual de funcionalidades.