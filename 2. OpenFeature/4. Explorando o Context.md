# Resumo da Aula: Configuração Avançada de Feature Flags com FlagD e Open Feature

## Introdução
Nesta aula, o professor avança na configuração do **FlagD** como provedor do **Open Feature**, focando em testes mais complexos, como o uso de **variantes** com tipos corretos e a implementação de **rollout gradual** com regras de segmentação (**targeting**). O professor corrige um erro anterior relacionado ao tipo de variante (string vs. booleano) e introduz o uso de contexto para segmentação, replicando funcionalidades do Unleash, como constraints baseadas em `user` e `group`. A aula também prepara para a criação de um **Docker Compose** na próxima etapa, para simplificar a execução do ambiente.

## Conteúdo Principal

### Correção de Erro com Variantes
- **Problema Identificado**:
  - Na aula anterior, o método `getBooleanValue` retornou um erro (`type mismatch`) porque as variantes da flag `loginPage` no arquivo `flags.json` eram strings (`"logar"` e `"entrar"`), mas o método esperava valores booleanos.
  - O professor esclarece que o Open Feature exige correspondência de tipo: `getBooleanValue` para booleanos, `getStringValue` para strings, `getNumberValue` para números, e `getObjectValue` para objetos.
- **Correção**:
  - Para usar strings, o código é ajustado para `getStringValue` e `getStringDetails`:
    ```javascript
    const flag = 'loginPage';
    const value = await client.getStringValue(flag, 'default');
    console.log({ value });
    ```
  - Com `flags.json` configurado como:
    ```json
    {
      "$schema": "https://flagd.dev/schema/v0/flags.json",
      "flags": {
        "loginPage": {
          "state": "ENABLED",
          "variants": {
            "A": "logar",
            "B": "entrar"
          },
          "defaultVariant": "A"
        }
      }
    }
    ```
  - **Teste**:
    - Com `defaultVariant: "A"`, `getStringValue` retorna `"logar"`.
    - Alterando para `defaultVariant: "B"`, retorna `"entrar"`.
    - O FlagD sincroniza automaticamente as alterações no arquivo, refletidas nos testes.

### Configuração de Rollout Gradual
- **Adaptação para Booleanos**:
  - Para replicar o rollout gradual do Unleash, o professor ajusta a flag `loginPage` para usar valores booleanos:
    ```json
    {
      "$schema": "https://flagd.dev/schema/v0/flags.json",
      "flags": {
        "loginPage": {
          "state": "ENABLED",
          "variants": {
            "on": true,
            "off": false
          },
          "defaultVariant": "on",
          "targeting": {
            "fractional": [
              ["on", 10],
              ["off", 90]
            ]
          }
        }
      }
    }
    ```
  - **Explicação**:
    - **`targeting.fractional`**: Define um rollout de 10% para a variante `on` (`true`) e 90% para `off` (`false`).
    - O FlagD avalia a distribuição com base em um hash do contexto, similar ao comportamento do Unleash.
- **Teste**:
  - O código Node.js usa `getBooleanValue` e `getBooleanDetails`:
    ```javascript
    const flag = 'loginPage';
    const value = await client.getBooleanValue(flag, false);
    const details = await client.getBooleanDetails(flag, false);
    console.log({ value, details });
    ```
  - Com `fractional: [["on", 10], ["off", 90]]`, a flag retorna `true` em ~10% das requisições e `false` em ~90%, refletindo o rollout configurado.
  - O comportamento de cache do FlagD é semelhante ao Unleash, com sincronização automática ao salvar o arquivo.

### Configuração de Targeting com Contexto
- **Nova Flag com Segmentação**:
  - Uma nova flag (`newFlag`) é criada para demonstrar segmentação com contexto:
    ```json
    {
      "$schema": "https://flagd.dev/schema/v0/flags.json",
      "flags": {
        "newFlag": {
          "state": "ENABLED",
          "variants": {
            "on": true,
            "off": false
          },
          "defaultVariant": "on",
          "targeting": {
            "if": [
              {
                "==": [
                  { "var": "user" },
                  "RocketseatUser"
                ]
              },
              {
                "==": [
                  { "var": "group" },
                  "RocketseatGroup"
                ]
              },
              "on",
              "off"
            ]
          }
        }
      }
    }
    ```
  - **Explicação**:
    - **`targeting.if`**: Define condições lógicas com operador `AND` (ambas devem ser verdadeiras):
      - `user == "RocketseatUser"`.
      - `group == "RocketseatGroup"`.
    - Se ambas forem verdadeiras, retorna a variante `on` (`true`); caso contrário, retorna `off` (`false`).
- **Código Node.js**:
  ```javascript
  const flag = 'newFlag';
  const context = {
    user: 'RocketseatUser',
    group: 'RocketseatGroup'
  };
  const value = await client.getBooleanValue(flag, false, context);
  const details = await client.getBooleanDetails(flag, false, context);
  console.log({ value, details });
  ```
  - **Testes**:
    - Com `context` correto (`user: "RocketseatUser"`, `group: "RocketseatGroup"`), retorna `true`.
    - Com `user: "RocketseatUserOld"`, retorna `false`, pois a condição não é atendida.
    - O uso de `context` no `getBooleanValue` e `getBooleanDetails` é essencial para avaliar as regras de segmentação.

### Playground do FlagD
- **Utilidade**: O playground no site `flagd.dev` é usado para validar o JSON da flag antes de aplicá-lo, simulando o comportamento com diferentes contextos.
  - Exemplo: Testar `newFlag` com `user: "RocketseatUser"` e `group: "RocketseatGroup"` retorna `true`; com valores incorretos, retorna `false`.
- **Vantagem**: Compensa a ausência de UI, permitindo testes rápidos e validação da lógica.

### Boas Práticas
- **Tipagem Correta**: Usar o método apropriado (`getBooleanValue`, `getStringValue`, etc.) conforme o tipo da variante para evitar erros de tipo.
- **Contexto**: Sempre passar o contexto necessário para regras de segmentação, especialmente em flags com `targeting`.
- **Organização do Código**: Definir o `context` como uma variável separada evita duplicação e facilita manutenção.
- **Validação no Playground**: Testar o JSON no playground antes de aplicá-lo reduz erros na aplicação.

### Próximos Passos
- A próxima aula criará um **Docker Compose** para simplificar a execução do FlagD, substituindo o comando `docker run` usado nesta aula, e consolidará os conceitos com mais exemplos práticos.

## Conclusão
A aula corrige o uso de tipos nas variantes, implementa **rollout gradual** com `fractional` e segmentação com `targeting` no FlagD, replicando funcionalidades do Unleash, como constraints. A integração com o Open Feature é consolidada, com testes demonstrando o comportamento esperado das flags `loginPage` e `newFlag`. A sincronização automática do FlagD e o uso do playground destacam sua praticidade, apesar da complexidade do JSON. A aula prepara para a configuração do Docker Compose, simplificando o ambiente e aprofundando a exploração do Open Feature.