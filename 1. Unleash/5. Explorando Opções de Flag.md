# Resumo da Aula: Configuração de Constraints e Campos Customizados no Unleash

## Introdução
Nesta aula, o professor avança na integração prática do Unleash com a aplicação Node.js, focando na configuração de **constraints** (restrições) para segmentação de Feature Flags e na utilização de campos customizados, como `groupId`. O objetivo é demonstrar como controlar a ativação de uma flag com base em propriedades específicas passadas pela aplicação, como `userId` ou `groupId`, e explorar as opções de segmentação oferecidas pelo Unleash, incluindo o uso de diferentes condições. A aula também prepara para a discussão futura sobre **variantes** no rollout gradual.

## Conteúdo Principal

### Configuração de Constraints
- **Definição**: Constraints são condições que restringem a ativação de uma Feature Flag com base em valores específicos de campos de contexto, como `userId` ou `groupId`.
- **Exemplo Prático**:
  - No Unleash, a flag `login_page` é configurada com uma constraint no campo `userId`, exigindo o valor `RocketseatUser` para ativação.
  - A estratégia de rollout está definida como **Gradual Rollout** com 90% de ativação, mas apenas para usuários com `userId` igual a `RocketseatUser`. Isso significa que, dentro do grupo especificado, 90% dos usuários verão a nova funcionalidade, enquanto 10% verão a antiga.
- **Teste na Aplicação**:
  - No código Node.js, a função `unleash.isEnabled('login_page', { userId: 'RocketseatUser' })` retorna `true` para 90% das requisições, conforme configurado.
  - Ao alterar o `userId` para `RocketseatUserOld`, a função retorna `false`, pois o valor não atende à constraint.
  - Mesmo com rollout de 100%, a flag só retorna `true` se o `userId` for `RocketseatUser`, demonstrando o controle granular oferecido pelas constraints.

### Campos Customizados
- **Context Fields**:
  - O Unleash suporta campos padrão como `userId` e `sessionId`, mas também permite criar campos customizados, como `groupId`, para segmentação específica.
  - O professor altera a constraint de `userId` para `groupId` com o valor `RocketseatUser`. A aplicação é atualizada para passar `{ properties: { groupId: 'RocketseatUser' } }` no método `isEnabled`.
  - Testes mostram que `groupId: 'RocketseatUser'` retorna `true`, enquanto `groupId: 'RocketseatUserOld'` retorna `false`, confirmando o funcionamento da constraint com campos customizados.
- **Propriedades Customizadas**:
  - Campos customizados são passados como parte do objeto `properties` no contexto da requisição, diferentemente de campos padrão como `userId`, que têm tipagem direta no Unleash.
  - Essa abordagem permite flexibilidade para definir qualquer campo necessário, como IDs de grupos ou outras propriedades específicas da aplicação.

### Outras Condições de Constraints
- **Operadores**:
  - Além de `IS_ONE_OF` (usado no exemplo, onde o valor deve estar em uma lista), o Unleash suporta outros operadores, como:
    - `IS_NOT_ONE_OF`: Exclui valores específicos.
    - `STRING_CONTAINS`, `STRING_STARTS_WITH`, `STRING_ENDS_WITH`: Para comparação de strings.
    - Operadores para números e versionamento (ex.: `SemVer` para controlar ativação com base em versões da aplicação, como exibir apenas para versão 1.0 ou superior).
  - Esses operadores ampliam as possibilidades de segmentação, permitindo cenários como ativação por faixa de versão ou padrões de texto.
- **Boa Prática**:
  - Cada valor em uma constraint (ex.: lista de `userId` ou `groupId`) deve ter no máximo 100 caracteres.
  - Múltiplos valores podem ser adicionados, separados por vírgulas, para incluir vários IDs ou grupos na mesma constraint.

### Integração com a Aplicação
- **Código Node.js**:
  - A função `unleash.isEnabled` aceita um objeto de contexto com campos padrão (`userId`, `sessionId`) ou customizados (`properties: { groupId: '...' }`).
  - O Unleash avalia as constraints e retorna um booleano (`true` ou `false`), que a aplicação usa para decidir se exibe ou não a funcionalidade.
- **Cache e Propagação**:
  - Alterações no Unleash (ex.: mudar constraints ou valores) podem levar alguns segundos para refletir na aplicação devido a cache, especialmente em cenários reais.
  - O professor recomenda limpar o cache ou esperar um curto período para garantir que as mudanças sejam aplicadas.

### Estratégia Standard com Constraints
- Constraints também podem ser aplicadas à estratégia **Standard**, onde a flag é ativada/desativada para todos, mas apenas para usuários que atendem às condições (ex.: `groupId: 'RocketseatUser'`).
- Isso permite usar a estratégia Standard para ativação total, mas restrita a um grupo específico, combinando simplicidade com segmentação.

### Próximos Passos
- A próxima aula abordará **variantes**, um recurso exclusivo do rollout gradual que permite definir diferentes versões de uma funcionalidade (ex.: diferentes layouts de uma tela) e associá-las a porcentagens ou condições específicas.

## Conclusão
A aula aprofunda a configuração de Feature Flags no Unleash, com ênfase no uso de **constraints** para segmentação granular baseada em campos como `userId` ou `groupId`. O professor demonstra como integrar essas restrições com uma aplicação Node.js, destacando a flexibilidade de campos customizados e operadores avançados, como versionamento. A capacidade de alternar entre estratégias (Gradual Rollout e Standard) com constraints reforça o controle fino do Unleash sobre funcionalidades. A aula prepara o terreno para explorar variantes, prometendo cenários mais complexos de personalização de features.